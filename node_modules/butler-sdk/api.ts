/* tslint:disable */
/* eslint-disable */
/**
 * Butler REST API Documentation
 *        Welcome to Butler API Documentation and Explorer       Butler API is built on and conforms to Open API 3.0 spec.       This enables you to automatically generate language specific clients for       languages/frameworks listed here: https://openapi-generator.tech/docs/generators/#client-generators       
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */
export enum AppRunStatus {
    InProgress = 'InProgress',
    Completed = 'Completed',
    Failed = 'Failed',
    Waiting = 'Waiting'
}

/**
 * 
 * @export
 * @interface AppRunStatusDto
 */
export interface AppRunStatusDto {
    /**
     * 
     * @type {string}
     * @memberof AppRunStatusDto
     */
    appRunId: string;
    /**
     * 
     * @type {AppRunStatus}
     * @memberof AppRunStatusDto
     */
    status: AppRunStatus;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DocExConfidence {
    High = 'High',
    Low = 'Low',
    UserReviewed = 'UserReviewed'
}

/**
 * 
 * @export
 * @interface DocumentExtractionResultsDto
 */
export interface DocumentExtractionResultsDto {
    /**
     * ID of the document
     * @type {string}
     * @memberof DocumentExtractionResultsDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentExtractionResultsDto
     */
    fileName: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentExtractionResultsDto
     */
    mimeType: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentExtractionResultsDto
     */
    documentType: string;
    /**
     * 
     * @type {Array<ExtractedFieldDto>}
     * @memberof DocumentExtractionResultsDto
     */
    extractedFields: Array<ExtractedFieldDto>;
    /**
     * 
     * @type {Array<ExtractedTableDto>}
     * @memberof DocumentExtractionResultsDto
     */
    tables: Array<ExtractedTableDto>;
    /**
     * 
     * @type {DocExConfidence}
     * @memberof DocumentExtractionResultsDto
     */
    confidenceScore?: DocExConfidence;
    /**
     * Page range that extraction ran on. Only populated if the document was filtered
     * @type {ExtractionRangeDto}
     * @memberof DocumentExtractionResultsDto
     */
    extractionRange?: ExtractionRangeDto;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DocumentStatus {
    UploadingFile = 'UploadingFile',
    DetectingText = 'DetectingText',
    ExtractingData = 'ExtractingData',
    WaitingForButlerOpsReview = 'WaitingForButlerOpsReview',
    WaitingForUserReview = 'WaitingForUserReview',
    Completed = 'Completed',
    Failed = 'Failed'
}

/**
 * 
 * @export
 * @interface ExtraResultsDto
 */
export interface ExtraResultsDto {
    /**
     * Extra lineBlocks, only present if requested. If this is an old document, or extra results otherwise failed to generate, then the value will be null
     * @type {object}
     * @memberof ExtraResultsDto
     */
    lineBlocks?: object | null;
    /**
     * Extra formFields, only present if requested. If this is an old document, or extra results otherwise failed to generate, then the value will be null
     * @type {object}
     * @memberof ExtraResultsDto
     */
    formFields?: object | null;
    /**
     * Extra tables, only present if requested. If this is an old document, or extra results otherwise failed to generate, then the value will be null
     * @type {object}
     * @memberof ExtraResultsDto
     */
    tables?: object | null;
}
/**
 * 
 * @export
 * @interface ExtractedFieldDto
 */
export interface ExtractedFieldDto {
    /**
     * 
     * @type {string}
     * @memberof ExtractedFieldDto
     */
    fieldName: string;
    /**
     * 
     * @type {string}
     * @memberof ExtractedFieldDto
     */
    value: string;
    /**
     * 
     * @type {DocExConfidence}
     * @memberof ExtractedFieldDto
     */
    confidenceScore: DocExConfidence;
}
/**
 * 
 * @export
 * @interface ExtractedTableCellDto
 */
export interface ExtractedTableCellDto {
    /**
     * 
     * @type {string}
     * @memberof ExtractedTableCellDto
     */
    columnName: string;
    /**
     * 
     * @type {string}
     * @memberof ExtractedTableCellDto
     */
    value: string;
    /**
     * 
     * @type {DocExConfidence}
     * @memberof ExtractedTableCellDto
     */
    confidenceScore: DocExConfidence;
}
/**
 * 
 * @export
 * @interface ExtractedTableDto
 */
export interface ExtractedTableDto {
    /**
     * 
     * @type {string}
     * @memberof ExtractedTableDto
     */
    tableName: string;
    /**
     * 
     * @type {Array<ExtractedTableRowDto>}
     * @memberof ExtractedTableDto
     */
    rows: Array<ExtractedTableRowDto>;
    /**
     * 
     * @type {DocExConfidence}
     * @memberof ExtractedTableDto
     */
    confidenceScore: DocExConfidence;
}
/**
 * 
 * @export
 * @interface ExtractedTableRowDto
 */
export interface ExtractedTableRowDto {
    /**
     * 
     * @type {Array<ExtractedTableCellDto>}
     * @memberof ExtractedTableRowDto
     */
    cells: Array<ExtractedTableCellDto>;
}
/**
 * 
 * @export
 * @interface ExtractionRangeDto
 */
export interface ExtractionRangeDto {
    /**
     * Page number extraction started on, inclusive
     * @type {number}
     * @memberof ExtractionRangeDto
     */
    startPage: number;
    /**
     * Page number extraction ended on, inclusive
     * @type {number}
     * @memberof ExtractionRangeDto
     */
    endPage: number;
}
/**
 * 
 * @export
 * @interface ExtractionResultsDto
 */
export interface ExtractionResultsDto {
    /**
     * ID of the document
     * @type {string}
     * @memberof ExtractionResultsDto
     */
    documentId: string;
    /**
     * 
     * @type {DocumentStatus}
     * @memberof ExtractionResultsDto
     */
    documentStatus: DocumentStatus;
    /**
     * Name of the uploaded file
     * @type {string}
     * @memberof ExtractionResultsDto
     */
    fileName: string;
    /**
     * Mime Type of the uploaded file
     * @type {string}
     * @memberof ExtractionResultsDto
     */
    mimeType: string;
    /**
     * Name of the document type
     * @type {string}
     * @memberof ExtractionResultsDto
     */
    documentType: string;
    /**
     * 
     * @type {DocExConfidence}
     * @memberof ExtractionResultsDto
     */
    confidenceScore?: DocExConfidence;
    /**
     * Range of pages that extraction ran on. Only populated if the document was filtered
     * @type {ExtractionRangeDto}
     * @memberof ExtractionResultsDto
     */
    extractionRange?: ExtractionRangeDto;
    /**
     * Extracted form fields of this document. May be undefined if extraction not completed
     * @type {Array<ExtractedFieldDto>}
     * @memberof ExtractionResultsDto
     */
    formFields?: Array<ExtractedFieldDto>;
    /**
     * Extracted tables of this document. May be undefined if extraction not completed
     * @type {Array<ExtractedTableDto>}
     * @memberof ExtractionResultsDto
     */
    tables?: Array<ExtractedTableDto>;
    /**
     * Any \"extra\" results from extraction. These are lower-level results that you can use to implement extra post-processing logic, if needed. These are only available if the \"extra_results\" query parameter was set
     * @type {ExtraResultsDto}
     * @memberof ExtractionResultsDto
     */
    extraResults?: ExtraResultsDto;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ExtractionResultsSortBy {
    DocumentId = 'DocumentId'
}

/**
 * 
 * @export
 * @interface LoginBodyDto
 */
export interface LoginBodyDto {
    /**
     * Username (e.g. myemail@gmail.com)
     * @type {string}
     * @memberof LoginBodyDto
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof LoginBodyDto
     */
    password: string;
}
/**
 * 
 * @export
 * @interface PaginatedExtractionResultsDto
 */
export interface PaginatedExtractionResultsDto {
    /**
     * Whether there are more pages to fetch after this page
     * @type {boolean}
     * @memberof PaginatedExtractionResultsDto
     */
    hasNext: boolean;
    /**
     * Whether there are more pages to fetch before this page
     * @type {boolean}
     * @memberof PaginatedExtractionResultsDto
     */
    hasPrevious: boolean;
    /**
     * Total number of items across all pages
     * @type {number}
     * @memberof PaginatedExtractionResultsDto
     */
    totalCount: number;
    /**
     * Page of extraction results
     * @type {Array<ExtractionResultsDto>}
     * @memberof PaginatedExtractionResultsDto
     */
    items: Array<ExtractionResultsDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SortOrder {
    Asc = 'Asc',
    Desc = 'Desc'
}

/**
 * 
 * @export
 * @interface UploadDocumentResponseDto
 */
export interface UploadDocumentResponseDto {
    /**
     * The name of the file when it was uploaded.
     * @type {string}
     * @memberof UploadDocumentResponseDto
     */
    filename: string;
    /**
     * The ID of the document.
     * @type {string}
     * @memberof UploadDocumentResponseDto
     */
    documentId: string;
}
/**
 * 
 * @export
 * @interface UploadDocumentsUploadResponseDto
 */
export interface UploadDocumentsUploadResponseDto {
    /**
     * The ID of the newly created upload.
     * @type {string}
     * @memberof UploadDocumentsUploadResponseDto
     */
    uploadId: string;
    /**
     * An array of info about the documents uploaded.
     * @type {Array<UploadDocumentResponseDto>}
     * @memberof UploadDocumentsUploadResponseDto
     */
    documents: Array<UploadDocumentResponseDto>;
}

/**
 * AppsApi - axios parameter creator
 * @export
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the status of an extraction job started by the upload_documents endpoint
         * @param {string} appRunId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppRunStatus: async (appRunId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appRunId' is not null or undefined
            assertParamExists('getAppRunStatus', 'appRunId', appRunId)
            const localVarPath = `/api/apps/app_runs/{appRunId}/status`
                .replace(`{${"appRunId"}}`, encodeURIComponent(String(appRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get extracted results of an extraction job started by the upload_documents endpoint after it completes
         * @param {string} appRunId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentExtractionResults: async (appRunId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appRunId' is not null or undefined
            assertParamExists('getDocumentExtractionResults', 'appRunId', appRunId)
            const localVarPath = `/api/apps/app_runs/{appRunId}/document_extraction`
                .replace(`{${"appRunId"}}`, encodeURIComponent(String(appRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload documents (PDFs, and image formats) to your app to start an extraction job. Returns an appRunId that can be used to check the status of the extraction job, and get its results
         * @param {string} appId 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocuments: async (appId: string, files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('uploadDocuments', 'appId', appId)
            const localVarPath = `/api/apps/{appId}/upload_documents`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the status of an extraction job started by the upload_documents endpoint
         * @param {string} appRunId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppRunStatus(appRunId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppRunStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppRunStatus(appRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get extracted results of an extraction job started by the upload_documents endpoint after it completes
         * @param {string} appRunId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentExtractionResults(appRunId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentExtractionResultsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentExtractionResults(appRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload documents (PDFs, and image formats) to your app to start an extraction job. Returns an appRunId that can be used to check the status of the extraction job, and get its results
         * @param {string} appId 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDocuments(appId: string, files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocuments(appId, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the status of an extraction job started by the upload_documents endpoint
         * @param {string} appRunId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppRunStatus(appRunId: string, options?: any): AxiosPromise<AppRunStatusDto> {
            return localVarFp.getAppRunStatus(appRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get extracted results of an extraction job started by the upload_documents endpoint after it completes
         * @param {string} appRunId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentExtractionResults(appRunId: string, options?: any): AxiosPromise<Array<DocumentExtractionResultsDto>> {
            return localVarFp.getDocumentExtractionResults(appRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload documents (PDFs, and image formats) to your app to start an extraction job. Returns an appRunId that can be used to check the status of the extraction job, and get its results
         * @param {string} appId 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocuments(appId: string, files?: Array<any>, options?: any): AxiosPromise<void> {
            return localVarFp.uploadDocuments(appId, files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * 
     * @summary Get the status of an extraction job started by the upload_documents endpoint
     * @param {string} appRunId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public getAppRunStatus(appRunId: string, options?: any) {
        return AppsApiFp(this.configuration).getAppRunStatus(appRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get extracted results of an extraction job started by the upload_documents endpoint after it completes
     * @param {string} appRunId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public getDocumentExtractionResults(appRunId: string, options?: any) {
        return AppsApiFp(this.configuration).getDocumentExtractionResults(appRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload documents (PDFs, and image formats) to your app to start an extraction job. Returns an appRunId that can be used to check the status of the extraction job, and get its results
     * @param {string} appId 
     * @param {Array<any>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public uploadDocuments(appId: string, files?: Array<any>, options?: any) {
        return AppsApiFp(this.configuration).uploadDocuments(appId, files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticates and authorizes the user to access the API
         * @param {LoginBodyDto} loginBodyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginBodyDto: LoginBodyDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginBodyDto' is not null or undefined
            assertParamExists('login', 'loginBodyDto', loginBodyDto)
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticates and authorizes the user to access the API
         * @param {LoginBodyDto} loginBodyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginBodyDto: LoginBodyDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginBodyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticates and authorizes the user to access the API
         * @param {LoginBodyDto} loginBodyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginBodyDto: LoginBodyDto, options?: any): AxiosPromise<void> {
            return localVarFp.login(loginBodyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Authenticates and authorizes the user to access the API
     * @param {LoginBodyDto} loginBodyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginBodyDto: LoginBodyDto, options?: any) {
        return AuthApiFp(this.configuration).login(loginBodyDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueuesApi - axios parameter creator
 * @export
 */
export const QueuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a single document to the queue specified by <queueId> and returns the extracted results
         * @param {string} queueId ID of the queue
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractDocument: async (queueId: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueId' is not null or undefined
            assertParamExists('extractDocument', 'queueId', queueId)
            const localVarPath = `/api/queues/{queueId}/documents`
                .replace(`{${"queueId"}}`, encodeURIComponent(String(queueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get paginated list of extraction results for documents matching the query params
         * @param {string} queueId ID of the queue
         * @param {string} uploadId ID of an upload
         * @param {string} [afterId] Fetch a page of results after this ID
         * @param {string} [beforeId] Fetch a page of results before this ID
         * @param {number} [limit] Number of results per page
         * @param {SortOrder} [sortOrder] Sort order. Default is ascending order.
         * @param {Set<'LineBlocks' | 'FormFields' | 'Tables'>} [extraResults] Which extra results you want to load, if any. These are lower-level results that you may use in your own post-processing. Omitted by default
         * @param {ExtractionResultsSortBy} [sortBy] Attribute to sort by. Default is DocumentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtractionResults: async (queueId: string, uploadId: string, afterId?: string, beforeId?: string, limit?: number, sortOrder?: SortOrder, extraResults?: Set<'LineBlocks' | 'FormFields' | 'Tables'>, sortBy?: ExtractionResultsSortBy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueId' is not null or undefined
            assertParamExists('getExtractionResults', 'queueId', queueId)
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('getExtractionResults', 'uploadId', uploadId)
            const localVarPath = `/api/queues/{queueId}/extraction_results`
                .replace(`{${"queueId"}}`, encodeURIComponent(String(queueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (afterId !== undefined) {
                localVarQueryParameter['afterId'] = afterId;
            }

            if (beforeId !== undefined) {
                localVarQueryParameter['beforeId'] = beforeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (uploadId !== undefined) {
                localVarQueryParameter['uploadId'] = uploadId;
            }

            if (extraResults) {
                localVarQueryParameter['extraResults'] = extraResults;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload documents to the queue specified by <queueId> for processing
         * @param {string} queueId ID of the queue
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocumentsToQueue: async (queueId: string, files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueId' is not null or undefined
            assertParamExists('uploadDocumentsToQueue', 'queueId', queueId)
            const localVarPath = `/api/queues/{queueId}/uploads`
                .replace(`{${"queueId"}}`, encodeURIComponent(String(queueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueuesApi - functional programming interface
 * @export
 */
export const QueuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueuesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a single document to the queue specified by <queueId> and returns the extracted results
         * @param {string} queueId ID of the queue
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extractDocument(queueId: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtractionResultsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extractDocument(queueId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get paginated list of extraction results for documents matching the query params
         * @param {string} queueId ID of the queue
         * @param {string} uploadId ID of an upload
         * @param {string} [afterId] Fetch a page of results after this ID
         * @param {string} [beforeId] Fetch a page of results before this ID
         * @param {number} [limit] Number of results per page
         * @param {SortOrder} [sortOrder] Sort order. Default is ascending order.
         * @param {Set<'LineBlocks' | 'FormFields' | 'Tables'>} [extraResults] Which extra results you want to load, if any. These are lower-level results that you may use in your own post-processing. Omitted by default
         * @param {ExtractionResultsSortBy} [sortBy] Attribute to sort by. Default is DocumentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtractionResults(queueId: string, uploadId: string, afterId?: string, beforeId?: string, limit?: number, sortOrder?: SortOrder, extraResults?: Set<'LineBlocks' | 'FormFields' | 'Tables'>, sortBy?: ExtractionResultsSortBy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExtractionResultsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtractionResults(queueId, uploadId, afterId, beforeId, limit, sortOrder, extraResults, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload documents to the queue specified by <queueId> for processing
         * @param {string} queueId ID of the queue
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDocumentsToQueue(queueId: string, files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadDocumentsUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocumentsToQueue(queueId, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueuesApi - factory interface
 * @export
 */
export const QueuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueuesApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a single document to the queue specified by <queueId> and returns the extracted results
         * @param {string} queueId ID of the queue
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractDocument(queueId: string, file?: any, options?: any): AxiosPromise<ExtractionResultsDto> {
            return localVarFp.extractDocument(queueId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get paginated list of extraction results for documents matching the query params
         * @param {string} queueId ID of the queue
         * @param {string} uploadId ID of an upload
         * @param {string} [afterId] Fetch a page of results after this ID
         * @param {string} [beforeId] Fetch a page of results before this ID
         * @param {number} [limit] Number of results per page
         * @param {SortOrder} [sortOrder] Sort order. Default is ascending order.
         * @param {Set<'LineBlocks' | 'FormFields' | 'Tables'>} [extraResults] Which extra results you want to load, if any. These are lower-level results that you may use in your own post-processing. Omitted by default
         * @param {ExtractionResultsSortBy} [sortBy] Attribute to sort by. Default is DocumentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtractionResults(queueId: string, uploadId: string, afterId?: string, beforeId?: string, limit?: number, sortOrder?: SortOrder, extraResults?: Set<'LineBlocks' | 'FormFields' | 'Tables'>, sortBy?: ExtractionResultsSortBy, options?: any): AxiosPromise<PaginatedExtractionResultsDto> {
            return localVarFp.getExtractionResults(queueId, uploadId, afterId, beforeId, limit, sortOrder, extraResults, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload documents to the queue specified by <queueId> for processing
         * @param {string} queueId ID of the queue
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocumentsToQueue(queueId: string, files?: Array<any>, options?: any): AxiosPromise<UploadDocumentsUploadResponseDto> {
            return localVarFp.uploadDocumentsToQueue(queueId, files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueuesApi - object-oriented interface
 * @export
 * @class QueuesApi
 * @extends {BaseAPI}
 */
export class QueuesApi extends BaseAPI {
    /**
     * 
     * @summary Upload a single document to the queue specified by <queueId> and returns the extracted results
     * @param {string} queueId ID of the queue
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public extractDocument(queueId: string, file?: any, options?: any) {
        return QueuesApiFp(this.configuration).extractDocument(queueId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get paginated list of extraction results for documents matching the query params
     * @param {string} queueId ID of the queue
     * @param {string} uploadId ID of an upload
     * @param {string} [afterId] Fetch a page of results after this ID
     * @param {string} [beforeId] Fetch a page of results before this ID
     * @param {number} [limit] Number of results per page
     * @param {SortOrder} [sortOrder] Sort order. Default is ascending order.
     * @param {Set<'LineBlocks' | 'FormFields' | 'Tables'>} [extraResults] Which extra results you want to load, if any. These are lower-level results that you may use in your own post-processing. Omitted by default
     * @param {ExtractionResultsSortBy} [sortBy] Attribute to sort by. Default is DocumentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public getExtractionResults(queueId: string, uploadId: string, afterId?: string, beforeId?: string, limit?: number, sortOrder?: SortOrder, extraResults?: Set<'LineBlocks' | 'FormFields' | 'Tables'>, sortBy?: ExtractionResultsSortBy, options?: any) {
        return QueuesApiFp(this.configuration).getExtractionResults(queueId, uploadId, afterId, beforeId, limit, sortOrder, extraResults, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload documents to the queue specified by <queueId> for processing
     * @param {string} queueId ID of the queue
     * @param {Array<any>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public uploadDocumentsToQueue(queueId: string, files?: Array<any>, options?: any) {
        return QueuesApiFp(this.configuration).uploadDocumentsToQueue(queueId, files, options).then((request) => request(this.axios, this.basePath));
    }
}


